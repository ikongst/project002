/******************************************************************************
*
* Copyright 2006-2015 Freescale Semiconductor, Inc.
* Copyright 2016-2018 NXP
* 
* Revision 1.5
* AMMCLib v1.1.12 and higher
*
***************************************************************************/

#include "mc9s12zvml128.h"
#include "S12zvm_periph.h"
#include "freemaster.h"
#include "state_machine.h"
#include "mlib.h"
#include "gflib.h"
#include "gmclib.h"
#include "gdflib.h"
#include "motor_structure.h"
#include "S12ZVM_devconfig.h"
#include "meas_s12zvm.h"
#include "actuate_s12zvm.h"
#include "eeprom_S12Z.h"
#include "pwm_control.h"

// static configuration generated by MCAT
#include "PMSM_appconfig.h"
#include "motorinter.h"
//#include "lini.h"

#include <hidef.h> /* for EnableInterrupts macro */
#include "derivative.h" /* include peripheral declarations */
//#if _TL_FRAME_SUPPORT_==_TL_MULTI_FRAME
//#include "lin_lin21tl_api.h"
#include "lin.h"




/*****************************************************************************
*
* Definitions
*
*****************************************************************************/

/*****************************************************************************
*
* Variables Definition
*
*****************************************************************************/
pmsmDrive_t         drvFOC;         // Field Oriented Control Variables
driveStates_t 		cntrState;	    // Responsible for stateMachine state propagation
appFaultStatus_t	tempfaults;		// Temporary faults to be indicated inhere
appFaultStatus_t	permFaults;		// Permanent faults to be indicated inhere
fm_scale_t			fmScale;		// Scales for freemaster interface
measModule_t		meas;
tPos_mode			pos_mode;

static tBool focFastLoop(void);
static tBool focSlowLoop(void);
static tBool faultDetection();

// Interrupts
INTERRUPT void TIMchan0_ISR();
INTERRUPT void TIMchan3_ISR();
INTERRUPT void PTUTrigger0Done_ISR(void);
INTERRUPT void PTUTrigger1Done_ISR(void);
INTERRUPT void ADC0error_ISR(void);
INTERRUPT void ADC1error_ISR(void);
INTERRUPT void ADC0done_ISR(void);
INTERRUPT void ADC1done_ISR(void);
INTERRUPT void PMFreloadA_ISR(void);





// Debug variables
static tFrac16			reload_PmfCnt;
volatile unsigned int 	AdcErrorLDOK, AdcErrorRSTAR, AdcErrorTRIG, AdcErrorEOL, AdcErrorCMD, AdcErrorIA;
volatile unsigned int 	AdcError0, AdcError1, TrigError0, TrigError1;
volatile tBool useRawDCBusForElim = true;
// End of debug variables

// Open Loop and Closed loop speed ramp variants
volatile tFrac32    OL_SpeedRampInc = 0, CL_SpeedRampInc = 0, CL_SpeedRampDec = 0;

pwmControl_t pwmControlData;			//PWM input control data structure
static tBool pwmControlEnabled = false;	// Off by default

GDFLIB_FILTER_MA_T_F16 	f16pwmInputMA = GDFLIB_FILTER_MA_DEFAULT_F16;

/*************************************************************/
l_u16 Ref_speed;
unsigned int App_count=0;

#include "Common_LIB.h"
#include "Common.h"
#include "SystemSchedule.h"
unsigned char uc1msflag = 0;
void systick_1ms(void);
void systick_1ms(void)
{
	uc1msflag = FLAG_SET;
	
	SetFlag_1MS();
}


/*****************************************************************************
*
* Function: void main(void)
*
* Description: main function
*
*****************************************************************************/
void main(void)
{
	cpmu_init();
	pim_init();
	pmf_init();
	ptu_init();
	adc0_init();
	adc1_init();
	//sci0_init();
	sci1_init();
	gdu_init();
	EEPROM_Init(0x31);
	initTIM();
	initLIN();
	l_sys_init();
	l_ifc_init(LIN_NXP);
	
	FMSTR_Init();
	
	// Init state set and e_reset event is thrown to call the reset state
	cntrState.state   	= init;
	cntrState.event 	= e_reset;
	
	EnableInterrupts;
	
	// Initial call of the finite state machine 
	state_table[cntrState.event][cntrState.state]();
	
	//Default setting of a FOC Control Mode
	cntrState.usrControl.FOCcontrolMode		= speedControl;
	
	EnableInterrupts;
	
	SystemSchedule_Init();
	TIM0TSCR2_TOI	= 1;
	
	
	
	
    // eeprom write read test.
	unsigned char tempreadarr[16] = {0};
	unsigned char tempwritearr[16] = {0};
	unsigned char i = 0, j = 0;
	for(i=0; i < 32;i++)
	{
		for(j=0;j<16;j++)
		{
			tempwritearr[j]=i;
		}
		flashoperation_1(tempwritearr, i, 16);		
	}
	//-------------------------------------------

	
	
	// Loop
	for(;;)
	{
		
		SystemSchedule_Main();
		
		// FreeMASTER poll function call
		FMSTR_Poll();
		__RESET_WATCHDOG();
//       if(l_flg_tst_LIN_NXP_MotorCtrl_flag())   //
//       {
//    	   l_flg_clr_LIN_NXP_MotorCtrl_flag(); 
//    	   Ref_speed=l_u16_rd_LIN_NXP_RefSpeed();
//    	   MotorDrive_Regulation(Ref_speed*300,0);
//       }
//
//	   if(App_count>10000)
//	   {
//		   App_count=5000;//*(Meas_GetTemp_NTC(&meas));		     
//	       //l_u8_wr_LIN_NXP_NTC((l_u8)(MotorDrive_uiTemperatureNTC>>4));//refresh NTC Temperature
//	   }
		
	   			  
	}
}


/*****************************************************************************
*
* Function: void ADC0error_ISR(void)
*
* Description: ADC0 Error Interrupt Service Routine to track errors
*
*****************************************************************************/
INTERRUPT void ADC0error_ISR(void)
{
	char tmpAdcEIF;

	EnableInterrupts;

	AdcError0++;				// Increment the AdcError0 counter
	permFaults.mcu.B.ADC_Error = 1;	// Throw the ADC error
	tmpAdcEIF = ADC0EIF;		// read the error register

	if (tmpAdcEIF & 0x02)       // Load Ok Error 
	{
		AdcErrorLDOK++;
		ADC0EIF = 0x02;
	}
	if (tmpAdcEIF & 0x04)       // Restart Request Error
	{
		AdcErrorRSTAR++;
		ADC0EIF = 0x04;
	}
	if (tmpAdcEIF & 0x08)       // Trigger Error => Soft Reset
	{
		AdcErrorTRIG++;
		ADC0CTL_0_ADC_SR = 1;
	}
	if (tmpAdcEIF & 0x20)       // End Of List Error => Soft Reset 
	{
		AdcErrorEOL++;
		ADC0CTL_0_ADC_SR = 1;
	}
	if (tmpAdcEIF & 0x40)       // Command Value Error => Soft Reset
	{
		AdcErrorCMD++;
		ADC0CTL_0_ADC_SR = 1;
	}
	if (tmpAdcEIF & 0x80)       // Illegal Access Error => Soft Reset
	{
		AdcErrorIA++;
		ADC0CTL_0_ADC_SR = 1;
	}
	return;
}

/*****************************************************************************
*
* Function: void ADC1error_ISR(void)
*
* Description: ADC1 Error Interrupt Service Routine
*
*****************************************************************************/
INTERRUPT void ADC1error_ISR(void)
{
	char tmpAdcEIF;
	
	EnableInterrupts;
	AdcError1++;				// Increment the AdcError0 counter
	permFaults.mcu.B.ADC_Error = 1;	// Throw the ADC error
	tmpAdcEIF = ADC1EIF;		// read the error register

	if (tmpAdcEIF & 0x02)       // Load Ok Error
	{
		AdcErrorLDOK++;
		ADC1EIF = 0x02;
	}
	if (tmpAdcEIF & 0x04)       // Restart Request Error
	{
		AdcErrorRSTAR++;
		ADC1EIF = 0x04;
	}
	if (tmpAdcEIF & 0x08)       // Trigger Error => Soft Reset
	{
		AdcErrorTRIG++;
		ADC1CTL_0_ADC_SR = 1;
	}
	if (tmpAdcEIF & 0x20)		// End Of List Error => Soft Reset
	{       
		AdcErrorEOL++;
		ADC1CTL_0_ADC_SR = 1;
	}
	if (tmpAdcEIF & 0x40)		// Command Value Error => Soft Reset
	{
		AdcErrorCMD++;
		ADC1CTL_0_ADC_SR = 1;
	}
	if (tmpAdcEIF & 0x80)      	// Illegal Access Error => Soft Reset
	{
		AdcErrorIA++;
		ADC1CTL_0_ADC_SR = 1;
	}
	return;
}


/*****************************************************************************
*
* Function: void ADC0done_ISR(void)
*
* Description: ADC0 Conversion Done Interrupt Service Routine
*
*****************************************************************************/
INTERRUPT void ADC0done_ISR(void)
{
	EnableInterrupts;
	ADC0CONIF = 1;      // Clear flag
	return;
}

/***************************************************************************//*!
*
* @brief   ADC interrupt service routine for Current loop of FOC
*
* @param   void
*
* @return  none
*
******************************************************************************/
INTERRUPT void ADC1done_ISR(void)
{
	EnableInterrupts;
	ADC1CONIF = 1;      // Clear flag
	return;
}


/***************************************************************************//*!
*
* @brief   ADC interrupt service routine for Current loop of FOC
*
* @param   void
*
* @return  none
*
******************************************************************************/
INTERRUPT void PMFreloadA_ISR(void)
{
	static tBool getFcnStatus;
	
	
	//-------------------------------------------
	// 1ms period for system schedule.
	static unsigned char suc1mscntr = 0;
	suc1mscntr++;
	if(suc1mscntr>=10) // 10*100us = 1ms
	{
		suc1mscntr = 0;
		systick_1ms();		
	}
	//--------------------------------------------
				
	EnableInterrupts;
	
	PTT_PTT0 = 1; 		// set the PTT0 pin to track the code performance
	
	// PWM Control
	// If no signal is detected, disable the PWM control
	if(pwmControlData.ControlInputClass == PWM_NoSignalDetect)
		pwmControlEnabled = false;
	else
		pwmControlEnabled = true;
	
	// If PWM input control enabled, update the demanded speed 
	if(pwmControlEnabled)
	{
		//If the linear or high signal is detected, switch the app on
		if(pwmControlData.ControlInputClass >= PWM_LinearCtrlDetect)
		{
			cntrState.usrControl.switchAppOnOff = 1;
		}
		else
		{
			cntrState.usrControl.switchAppOnOff = 0;
			if(cntrState.state == fault)
				cntrState.usrControl.switchFaultClear = true;
		}
		//Store the demanded speed
		drvFOC.pospeControl.wRotElReq = GDFLIB_FilterMA_F16(pwmControlData.outputValue, &f16pwmInputMA);
	}
	else
		GDFLIB_FilterMAInit_F16(&f16pwmInputMA);	//If PWM control disabled, keep filtering the command

	 // User accessible switch for stopping the application.
	if (cntrState.usrControl.btFlipFlop ^ cntrState.usrControl.btFlipFlopTemp)
	{
		cntrState.usrControl.btFlipFlopTemp  = cntrState.usrControl.btFlipFlop;
		cntrState.usrControl.switchAppOnOff  = (cntrState.usrControl.btFlipFlop) ? false: true;
	}
	
	// User accessible switch for stopping the application.
	if (cntrState.usrControl.switchAppOnOff ^ cntrState.usrControl.switchAppOnOffState)
	{
		cntrState.usrControl.switchAppOnOffState  = cntrState.usrControl.switchAppOnOff;
		cntrState.event   = (cntrState.usrControl.switchAppOnOff) ? e_app_on: e_app_off;
	}
						
	getFcnStatus    =    true;
	
	// Phase currents and DCB voltage measurement
	getFcnStatus  = Meas_Get3PhCurrent(&meas, &drvFOC.iAbcFbck, drvFOC.svmSector);
	getFcnStatus &= Meas_GetTemperature(&meas);
	getFcnStatus &= Meas_GetTemp_NTC(&meas);
	
	MotorDrive_uiTemperature = 100;//150-(2400*100-((meas.measured.f16Temp.raw*5*1000*100)>>16))/525;
	
	//MotorDrive_uiTemperature   =(long)((long)(meas.measured.f16Temp.filt>>3)*645)>>12;   //add for Temperature sample
	//l_u8_wr_LIN_NXP_Temperature((l_u8)(MotorDrive_uiTemperature>>4)); //refresh Temperature	
	
	//MotorDrive_uiTemperatureNTC_Digital=(long)((long)meas.measured.f16NTC.filt*645)>>12;
	MotorDrive_uiTemperatureNTC_Digital=ADC1ResultList[0][2]>>4;// 10bit NTC digital needed.	
		
	getFcnStatus &= Meas_GetUdcVoltage(&meas, &drvFOC.uDcbFilter);
	//MotorDrive_uiVoltage= ((long)((long)(meas.measured.f16Udcb.filt>>3)*5*5*1000))>>12;   //add for voltage sample
	MotorDrive_uiVoltage= (long)((long)meas.measured.f16Udcb.filt*5*5*1000)>>15;   //add for voltage sample
	//l_u8_wr_LIN_NXP_ActVoltage((MotorDrive_uiVoltage));  //refresh voltage
	
	drvFOC.f16Udcb = meas.measured.f16Udcb.filt;
	   
	// Fault detection routine, must be executed prior application state machine
	getFcnStatus &= faultDetection();
	if (getFcnStatus)    cntrState.event = e_fault;
	
	// Execute State table with newly measured data
	state_table[cntrState.event][cntrState.state]();
	state_LED[cntrState.state]();

	App_count++;
	
	PTT_PTT0 = 0;			// clear the PTT0 pin to track the code performance
	
	FMSTR_Recorder();

	PMFFQCA_PWMRFA = 1; // Clear flag
	return;
}

/***************************************************************************//*!
*
* @brief   TIM channel 3 / input capture interrupt service routine for PWM input control evaluation
*
* @param   void
*
* @return  none
*
******************************************************************************/
INTERRUPT void TIM0chan3_ISR(void)
{
	PWMDetection_INT();
	TIM0TFLG1 = TIM0TFLG1_C3F_MASK;
	return;
	
//	// Read PWM input control pin and update status
//	if(PWMControlUpdate(TIM0TC3, &pwmControlData))
//	// Read the PWM Control output
//	pwmControlData.outputValue = PWMControlGetOutputValue(&pwmControlData);
//		
//	// Toggle edge detection
//	if(pwmControlData.flags.risingEdge)
//	{	
//		TIM0TCTL4_EDG3A = 1;
//		TIM0TCTL4_EDG3B = 0;
//	}
//	if(pwmControlData.flags.fallingEdge)
//	{
//		TIM0TCTL4_EDG3A = 0;
//		TIM0TCTL4_EDG3B = 1;
//	}
//	
//	// Clear interrupt flag
//	TIM0TFLG1 = TIM0TFLG1_C3F_MASK; //TIM0TFLG1_C0F_MASK | TIM0TFLG1_C1F_MASK | TIM0TFLG1_C2F_MASK  | TIM0TFLG1_C3F_MASK;
}
/***************************************************************************//*!
*
* @brief   TIM overflow interrupt service routine for PWM input control evaluation
*
* @param   void
*
* @return  none
*
******************************************************************************/
INTERRUPT void TIM0overflow_ISR(void)
{
	TaskAnalysis_Overflow_INT(); // 65536 uS overflow.
	
	PWM_overflow_INT();
	TIM0TFLG2 = TIM0TFLG2_TOF_MASK; 
	return;
	
	
//	// Detect PWM input control period overflow (ultra low frequencies
//	if(PWMControlTimerOverflow(&pwmControlData))
//		{
//	      PWMControlInit(&pwmControlData);
//		  //if(pwmstate == 0)
//		  //{
//		   TIM0TCTL4_EDG3A = 1;	   //Rising edge
//	       TIM0TCTL4_EDG3B = 0;    //1
//		}
//	// Clear interrupt flag
//	TIM0TFLG2 = TIM0TFLG2_TOF_MASK; 
}


/***************************************************************************//*!
*
* @brief   After reset MCAT INIT
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateReset()
{
	tBool ResetFcnStatus = false;
	/*-----------------------------------------------------
	Application State Machine - state identification
	----------------------------------------------------- */
	// On entry
	if(cntrState.state != reset)
	{
		// Entering state fault
		cntrState.state   = reset;
		cntrState.event   = e_reset;
		
		Meas_Clear(&meas);
		
		// Init the DCBus filter and wait in the reset state till the DCBus charges
		// DCBus 1st order filter; Fcut = 100Hz, Ts = 100e-6
		drvFOC.uDcbFilter.trFiltCoeff.f16B0    = UDCB_IIR_B0;
		drvFOC.uDcbFilter.trFiltCoeff.f16B1    = UDCB_IIR_B1;
		drvFOC.uDcbFilter.trFiltCoeff.f16A1    = UDCB_IIR_A1;
		GDFLIB_FilterIIR1Init_F16(&drvFOC.uDcbFilter);
	}
	// Turn off and keep the Actuator's output (PWM, GDU)
	DisableOutput();
	/*------------------------------------
	 * Freemaster variables
	 * ----------------------------------*/
	fmScale.current                                      = FM_I_SCALE;
	fmScale.voltage                                      = FM_U_SCALE;
	fmScale.dcb_voltage                                  = FM_U_DCB_SCALE;
	fmScale.speed_w_e                                    = FM_SPEED_RAD_EL_SCALE;
	fmScale.speed_n_m                                    = FM_SPEED_RPM_MEC_SCALE;
	fmScale.position                                     = FM_POSITION_DEG_SCALE;
	//fmScale.speed_ramp									 = FM_SPEED_RAMP_RPM_SCALE;
	
	drvFOC.alignCntrInit							   	= ALIGN_DURATION;
	drvFOC.alignVoltage 								= ALIGN_VOLTAGE;
	
	/*------------------------------------
	 * Currents
	 * ----------------------------------*/
	drvFOC.iAbcFbck.f16Arg1                = 0;
	drvFOC.iAbcFbck.f16Arg2                = 0;
	drvFOC.iAbcFbck.f16Arg3                = 0;
	
	drvFOC.iAlBeFbck.f16Arg1               = 0;
	drvFOC.iAlBeFbck.f16Arg2               = 0;
	
	drvFOC.currentLoop.pIDQReq->f16Arg1		= 0;
	drvFOC.currentLoop.pIDQReq->f16Arg2		= 0;
	
	drvFOC.currentLoop.pIDQFbck->f16Arg1	= 0;
	drvFOC.currentLoop.pIDQFbck->f16Arg2	= 0;
	
	/*------------------------------------
	 * Voltages
	 * ----------------------------------*/
	drvFOC.uAlBeReq.f16Arg1                = 0;
	drvFOC.uAlBeReq.f16Arg2                = 0;
	
	drvFOC.uAlBeReqDCB.f16Arg1             = 0;
	drvFOC.uAlBeReqDCB.f16Arg2             = 0;
	
	drvFOC.uDQReq.f16Arg1                  = 0;
	drvFOC.uDQReq.f16Arg2                  = 0;
	
	/*------------------------------------
	 * Speed/Position
	 * ----------------------------------*/
	drvFOC.thTransform.f16Arg1             = 0;
	drvFOC.thTransform.f16Arg2             = 0;
	
	/*------------------------------------
	 * SVC-PWM variables
	 * ----------------------------------*/
	drvFOC.svmSector                       = 1;
	
	drvFOC.pwm16.f16Arg1                   = 0;
	drvFOC.pwm16.f16Arg2                   = 0;
	drvFOC.pwm16.f16Arg3                   = 0;
	
	/*------------------------------------
	 * FOC variables
	 * ----------------------------------*/
	// Current PI controllers
	drvFOC.iCLoop_Limit						= CLOOP_LIMIT;
	
	drvFOC.currentLoop.pPIrAWD.f16CC1sc		= D_CC1SC;
	drvFOC.currentLoop.pPIrAWD.f16CC2sc		= D_CC2SC;
	drvFOC.currentLoop.pPIrAWD.u16NShift	= D_NSHIFT;
	
	drvFOC.currentLoop.pPIrAWD.f16UpperLimit = CLOOP_LIMIT;
	drvFOC.currentLoop.pPIrAWD.f16LowerLimit = MLIB_Neg_F16(CLOOP_LIMIT);
	
	drvFOC.currentLoop.pPIrAWQ.f16CC1sc		= Q_CC1SC;
	drvFOC.currentLoop.pPIrAWQ.f16CC2sc		= Q_CC2SC;
	drvFOC.currentLoop.pPIrAWQ.u16NShift	= Q_NSHIFT;
	
	drvFOC.currentLoop.pPIrAWQ.f16UpperLimit = CLOOP_LIMIT;
	drvFOC.currentLoop.pPIrAWQ.f16LowerLimit = MLIB_Neg_F16(CLOOP_LIMIT);
	
	drvFOC.currentLoop.pIDQFbck				= &drvFOC.iDQFbck;
	drvFOC.currentLoop.pIDQReq				= &drvFOC.iDQReq;
	
	AMCLIB_CurrentLoopInit_F16(&drvFOC.currentLoop);
	
	drvFOC.elimDcbRip.f16ModIndex          = FRAC16(0.866025403784439);
	drvFOC.elimDcbRip.f16ArgDcBusMsr       = 0;
	
	drvFOC.pospeSensorless.dutyCycleLimit.f16UpperLimit = CLOOP_LIMIT;
	drvFOC.pospeSensorless.dutyCycleLimit.f16LowerLimit = MLIB_Neg_F16(CLOOP_LIMIT);
	
	OL_SpeedRampInc = OL_START_RAMP_INC;
	//OL_SpeedRampDec = OL_START_RAMP_DEC;
	CL_SpeedRampInc = SPEED_RAMP_UP;
	CL_SpeedRampDec = SPEED_RAMP_DOWN;
	
	drvFOC.speedRampPos.f32RampUp          = OL_SpeedRampInc;
	drvFOC.speedRampPos.f32RampDown        = OL_SpeedRampInc;			//would be OL_SpeedRampDec, if needed
	drvFOC.speedRampPos.f32State           = 0;
	
	drvFOC.speedRampNeg.f32RampUp          = OL_SpeedRampInc;
	drvFOC.speedRampNeg.f32RampDown        = OL_SpeedRampInc;			//would be OL_SpeedRampDec, if needed
	drvFOC.speedRampNeg.f32State           = 0;
	
	drvFOC.pospeControl.wRotElReq		   = 0;
	drvFOC.pospeControl.wRotEl			   = 0;
	drvFOC.pospeControl.wRotElReqRamp      = 0;
	
	drvFOC.speedLoop.pPIpAWQ.f16PropGain		= SPEED_PI_PROP_GAIN;
	drvFOC.speedLoop.pPIpAWQ.s16PropGainShift 	= SPEED_PI_PROP_SHIFT;
	drvFOC.speedLoop.pPIpAWQ.f16IntegGain		= SPEED_PI_INTEG_GAIN;
	drvFOC.speedLoop.pPIpAWQ.s16IntegGainShift	= SPEED_PI_INTEG_SHIFT;
	drvFOC.speedLoop.pPIpAWQ.f16UpperLimit		= SPEED_LOOP_HIGH_LIMIT;
	drvFOC.speedLoop.pPIpAWQ.f16LowerLimit		= SPEED_LOOP_LOW_LIMIT;
	drvFOC.speedLoop.pRamp.f32RampUp			= OL_SpeedRampInc;
	drvFOC.speedLoop.pRamp.f32RampDown			= OL_SpeedRampInc;
	drvFOC.speedLoop.pFilterW.u16NSamples		= POSPE_SPEED_FILTER_MA_NPOINT;
	
	AMCLIB_SpeedLoopInit_F16 (&drvFOC.speedLoop);
	
	// Position observer output
	drvFOC.pospeSensorless.wRotEl   	   	= 0;
	drvFOC.pospeSensorless.thRotEl		   	= 0;
	
	drvFOC.pospeSensorless.DQtoGaDeError	= 0; 		
	drvFOC.pospeSensorless.bEMFObs.pParamD.f16CC1sc        = BEMF_DQ_CC1_GAIN;
	drvFOC.pospeSensorless.bEMFObs.pParamD.f16CC2sc        = BEMF_DQ_CC2_GAIN;
	drvFOC.pospeSensorless.bEMFObs.pParamD.f16LowerLimit   = FRAC16(-1.0);
	drvFOC.pospeSensorless.bEMFObs.pParamD.f16UpperLimit   = FRAC16(1.0);
	drvFOC.pospeSensorless.bEMFObs.pParamD.u16NShift       = BEMF_DQ_NSHIFT;
	drvFOC.pospeSensorless.bEMFObs.pParamQ.f16CC1sc        = BEMF_DQ_CC1_GAIN;
	drvFOC.pospeSensorless.bEMFObs.pParamQ.f16CC2sc        = BEMF_DQ_CC2_GAIN;
	drvFOC.pospeSensorless.bEMFObs.pParamQ.f16LowerLimit   = FRAC16(-1.0);
	drvFOC.pospeSensorless.bEMFObs.pParamQ.f16UpperLimit   = FRAC16(1.0);
	drvFOC.pospeSensorless.bEMFObs.pParamQ.u16NShift       = BEMF_DQ_NSHIFT;
	drvFOC.pospeSensorless.bEMFObs.s16Shift 				= BEMF_SHIFT;
	drvFOC.pospeSensorless.bEMFObs.f16UGain					= U_GAIN;
	drvFOC.pospeSensorless.bEMFObs.f16WIGain				= WI_GAIN;
	drvFOC.pospeSensorless.bEMFObs.f16EGain					= E_GAIN;
	drvFOC.pospeSensorless.bEMFObs.f16IGain					= I_GAIN;
	
	AMCLIB_BemfObsrvDQInit_F16 (&drvFOC.pospeSensorless.bEMFObs);
	
	drvFOC.pospeSensorless.TrackObsrv.pParamPI.f16CC1sc        = TO_CC1SC;
	drvFOC.pospeSensorless.TrackObsrv.pParamPI.f16CC2sc        = TO_CC2SC;
	drvFOC.pospeSensorless.TrackObsrv.pParamPI.f16LowerLimit   = FRAC16(-1.0);
	drvFOC.pospeSensorless.TrackObsrv.pParamPI.f16UpperLimit   = FRAC16(1.0);
	drvFOC.pospeSensorless.TrackObsrv.pParamPI.u16NShift       = TO_NSHIFT;	
	drvFOC.pospeSensorless.TrackObsrv.pParamInteg.f16C1 		= TO_THETA_GAIN;
	drvFOC.pospeSensorless.TrackObsrv.pParamInteg.u16NShift 	= TO_THETA_SHIFT;
	
	AMCLIB_TrackObsrvInit_F16(&drvFOC.pospeSensorless.TrackObsrv);
	
	drvFOC.pospeSensorless.wRotEl			= 0;
	drvFOC.pospeSensorless.thRotEl			= 0;
	drvFOC.pospeSensorless.wRotElMatch_1	= MERG_SPEED_1_TRH;
	drvFOC.pospeSensorless.wRotElMatch_2	= MERG_SPEED_2_TRH;
	
	drvFOC.pospeSensorless.iQUpperLimit		= SPEED_LOOP_HIGH_LIMIT;
	drvFOC.pospeSensorless.iQLowerLimit		= SPEED_LOOP_LOW_LIMIT;
	
	drvFOC.pospeOpenLoop.integ.f16InK1 		= 0;
	drvFOC.pospeOpenLoop.integ.f32State 	= 0;
	drvFOC.pospeOpenLoop.integ.f16C1 		= SCALAR_INTEG_GAIN;
	drvFOC.pospeOpenLoop.integ.u16NShift 	= SCALAR_INTEG_SHIFT;
	
	drvFOC.pospeOpenLoop.thRotEl			= 0;
	drvFOC.pospeOpenLoop.wRotEl				= 0;
	
	drvFOC.pospeOpenLoop.iQUpperLimit		= OL_START_I;
	drvFOC.pospeOpenLoop.iQLowerLimit		= MLIB_Neg_F16(drvFOC.pospeOpenLoop.iQUpperLimit);
	
	// Scalar control
	drvFOC.scalarControl.VHzRatioReq		= SCALAR_VHZ_FACTOR_GAIN;
	drvFOC.scalarControl.VHzRatioReq_Shift	= SCALAR_VHZ_FACTOR_SHIFT;
	
	// Decoupling
	//GMCLIB_DECOUPLINGPMSM_T_F16		decouplingPar;	// Ld-Lq decoupling
	drvFOC.decouplingPar.f16Kd 				= FRAC16(0.295678);		//Lq * wmax * Imax/Umax = 25.1 uH * 2356.194 * 125 / 25
	drvFOC.decouplingPar.s16KdShift			= 0;
	drvFOC.decouplingPar.f16Kq				= FRAC16(0.200276);		//Ld * wmax * Imax/Umax = 17.0 uH * 2356.194 * 125 / 25
	drvFOC.decouplingPar.s16KqShift			= 0;
	
	SWLIBS_2Syst_F16				uDQdecoupled;	// Udq voltage after decoupling
	
	
	// Default mode of operation
	cntrState.usrControl.controlMode		= automatic;
	pos_mode								= force;
	
    //PWM input control
	pwmControlData.config.noSignalLevel		= FRAC16(0.05);					// No signal detected below 5%
	pwmControlData.config.noSignalOutput	= 0;							// No signal output
	pwmControlData.config.hystLowSignalOff	= FRAC16(0.1);					// Low signal off at 10%
	pwmControlData.config.hystLowSignalOn	= FRAC16(0.15);					// Low signal on at 15%
	pwmControlData.config.linearSignalLevelMax	= FRAC16(0.85);				// Linear signal max at 85%
	pwmControlData.config.linearSignalOutputMax = FRAC16(2650.0/N_MAX);		// Max output set to nominal speed
	pwmControlData.config.linearSignalOutputMin = MERG_SPEED_2_TRH;			// Min output set to Merge2 speed
	pwmControlData.config.linearSignalSlope	= FRAC16(0.68254);				// Linear slope calculated as (2650/4500 - 500/4500) / (0.85 - 0.15)
	pwmControlData.config.linearSignalShift		= FRAC16(0.00873);			// Linear shift calculated as 500/4500 - 0.68254 * 0.15
	pwmControlData.config.lowSignalOutput	= 0;							// Low signal output
	pwmControlData.config.maxPeriod			= 62500;   //8HZ     25000;	    // Max period corresponds to 20 Hz with f_bus/50 precision prescaler
	pwmControlData.config.minPeriod			= 495;   //12HZ      495;		// Min period corresponds to 1 kHz with f_bus/50 precision prescaler

	
	PWMControlInit(&pwmControlData);
	EnableTIM();
	
	// Resets the filter with the measured raw values and waits for the DCBus to be charged
	if(meas.measured.f16Udcb.raw > 0)
	{
		drvFOC.uDcbFilter.f16FiltBufferX[0] = meas.measured.f16Udcb.raw;
		drvFOC.uDcbFilter.f32FiltBufferY[0] = MLIB_Convert_F32F16((tFrac16) meas.measured.f16Udcb.raw, FRAC16(1.0));
		
		if(meas.measured.f16Udcb.raw < U_DCB_UNDERVOLTAGE)	// If low voltage, stay in the reset state
			ResetFcnStatus = false;
		else												// else report reset done
			ResetFcnStatus = true; 	
	}
	
	if (ResetFcnStatus)
	{
		// Initialisation phase successfully done
		cntrState.event   = e_reset_done;  // prepare for transition to next state.
	}
	return;
}

/***************************************************************************//*!
*
* @brief   FAULT state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateFault()
{
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    // Entering state fault
	cntrState.state   = fault;
	cntrState.event   = e_fault;

	// Turn off Actuator's output (PWM, GDU)
	DisableOutput();
	
	// Indicate State Machine fault state invoked by irrelevant event call
	if((permFaults.mcu.R == 0)&&(permFaults.motor.R == 0)&&(permFaults.stateMachine.R == 0))
		permFaults.stateMachine.B.FOCError = 1;
	
    // Disable user application switch
    cntrState.usrControl.switchAppOnOff      = false;
    cntrState.usrControl.switchAppOnOffState = false;
    
    // Clear fault by FreeMASTER command.
    if (cntrState.usrControl.switchFaultClear)
    {
    	if(ClearDriverError() && ClearPMF_Faults() && ClearPTU_Errors())
    	{
			// Clear all of the HW/MCU faults such as GDU, PWM, ...

			// Clear permanent SW faults
			permFaults.mcu.R          = 0x0;      // Clear mcu faults
			permFaults.motor.R		  = 0x0;	  // Clear motor faults
			permFaults.stateMachine.R = 0x0;	  // Clear state machine faults
	
			// When all Faults cleared prepare for transition to next state.
			cntrState.usrControl.readFault             = true;
			cntrState.usrControl.switchFaultClear      = false;
			cntrState.event                            = e_fault_clear;
    	}
    }
	return;
}

/***************************************************************************//*!
*
* @brief   INIT state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateInit( )
{
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    tBool InitFcnStatus;
    cntrState.state                              = init;
    cntrState.event								 = e_init;

    //Switch off PWM output, GDU output
    DisableOutput();

    /*------------------------------------
     * General use variables
     * ----------------------------------*/
    InitFcnStatus                                         = false;

    /*------------------------------------
     * Application state machine variables
     * ----------------------------------*/
    // Reset state of all user control variables
    cntrState.usrControl.switchAppOnOff                      = false;
    cntrState.usrControl.switchAppOnOffState                 = false;
    cntrState.usrControl.switchFaultClear                    = false;
    cntrState.usrControl.switchAppReset                      = false;
    
    cntrState.usrControl.ledCounter							 = 0;
    cntrState.usrControl.ledFlashing						 = 1250;


    drvFOC.pospeControl.speedLoopCntr                       = 0;
    
    drvFOC.alignCntr								   	= drvFOC.alignCntrInit;
    
    InitFcnStatus = Meas_Clear(&meas);
    meas.param.u16CalibSamples                         = 10;    // number of samples = 2^u16CalibSamples
    meas.offset.f16Idcb.filtParam.u16NSamples		   = meas.param.u16CalibSamples;
 
    
    /*------------------------------------
     * Currents
     * ----------------------------------*/
    drvFOC.iAbcFbck.f16Arg1                = 0;
    drvFOC.iAbcFbck.f16Arg2                = 0;
    drvFOC.iAbcFbck.f16Arg3                = 0;

    drvFOC.iAlBeFbck.f16Arg1               = 0;
    drvFOC.iAlBeFbck.f16Arg2               = 0;
    
	drvFOC.currentLoop.pIDQReq->f16Arg1		= 0;
	drvFOC.currentLoop.pIDQReq->f16Arg2		= 0;

	drvFOC.currentLoop.pIDQFbck->f16Arg1	= 0;
	drvFOC.currentLoop.pIDQFbck->f16Arg2	= 0;
    
    drvFOC.pospeOpenLoop.iQLowerLimit		= MLIB_Neg_F16(drvFOC.pospeOpenLoop.iQUpperLimit);
    
    drvFOC.pospeSensorless.dutyCycleLimit.f16UpperLimit = drvFOC.iCLoop_Limit;
    drvFOC.pospeSensorless.dutyCycleLimit.f16LowerLimit = MLIB_Neg_F16(drvFOC.iCLoop_Limit);
    

    /*------------------------------------
     * Voltages
     * ----------------------------------*/
    drvFOC.uAlBeReq.f16Arg1                = 0;
    drvFOC.uAlBeReq.f16Arg2                = 0;

    drvFOC.uAlBeReqDCB.f16Arg1             = 0;
    drvFOC.uAlBeReqDCB.f16Arg2             = 0;

    drvFOC.uDQReq.f16Arg1                  = 0;
    drvFOC.uDQReq.f16Arg2                  = 0;

    /*------------------------------------
     * Speed/Position
     * ----------------------------------*/
    drvFOC.thTransform.f16Arg1             = 0;
    drvFOC.thTransform.f16Arg2             = 0;

    /*------------------------------------
     * SVC-PWM variables
     * ----------------------------------*/
    drvFOC.svmSector                       = 1;

    drvFOC.pwm16.f16Arg1                   = 0;
    drvFOC.pwm16.f16Arg2                   = 0;
    drvFOC.pwm16.f16Arg3                   = 0;

    /*------------------------------------
     * FOC variables
     * ----------------------------------*/
    
    AMCLIB_CurrentLoopInit_F16(&drvFOC.currentLoop);

    drvFOC.elimDcbRip.f16ModIndex          = FRAC16(0.866025403784439);
    drvFOC.elimDcbRip.f16ArgDcBusMsr       = 0;
 
    drvFOC.speedRampPos.f32RampUp          = OL_SpeedRampInc;
    drvFOC.speedRampPos.f32RampDown        = OL_SpeedRampInc;
    drvFOC.speedRampPos.f32State           = 0;
    
    drvFOC.speedRampNeg.f32RampUp          = OL_SpeedRampInc;
    drvFOC.speedRampNeg.f32RampDown        = OL_SpeedRampInc;
    drvFOC.speedRampNeg.f32State           = 0;
 
    AMCLIB_SpeedLoopInit_F16 (&drvFOC.speedLoop);
    
    drvFOC.pospeControl.wRotEl			   = 0;
    drvFOC.pospeControl.wRotElReqRamp      = 0;

    // Position observer
    drvFOC.pospeSensorless.wRotEl   	   	= 0;
    drvFOC.pospeSensorless.thRotEl		   	= 0;
    drvFOC.pospeSensorless.DQtoGaDeError	= 0;
    
    AMCLIB_BemfObsrvDQInit_F16 (&drvFOC.pospeSensorless.bEMFObs);
    AMCLIB_TrackObsrvInit_F16(&drvFOC.pospeSensorless.TrackObsrv);

    drvFOC.pospeOpenLoop.thRotEl			= 0;
    drvFOC.pospeOpenLoop.wRotEl				= 0;
    drvFOC.pospeOpenLoop.integ.f16InK1		= 0;
    drvFOC.pospeOpenLoop.integ.f32State		= 0;
    
    // Decoupling
    drvFOC.uDQdecoupled.f16Arg1				= 0;
    drvFOC.uDQdecoupled.f16Arg2				= 0;
 
    // Default mode of operation
    cntrState.usrControl.controlMode		= automatic;
    pos_mode								= force;

    if (!InitFcnStatus)
    {
    	// Fault in initialisation state
        tempfaults.stateMachine.B.InitError = 1;		// Mark the initialisation fault
        cntrState.event                     = e_fault;	// prepare for transition to fault state.
    }
    else
    {
    	// Initialisation phase successfully done
    	cntrState.event   = e_init_done;  // prepare for transition to next state.
    }
	return;
}

/***************************************************************************//*!
*
* @brief   READY state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateReady()
{
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    cntrState.state   = ready;
    cntrState.event   = e_ready;
    
    if(cntrState.usrControl.switchAppReset == true)
    {
    	cntrState.event = e_reset;
    	cntrState.usrControl.switchAppReset = false;
    }
	
    if(Runcommand)
    {
    	cntrState.usrControl.btFlipFlop=0; 
        cntrState.usrControl.btFlipFlopTemp=1;
    }
    	else
    {
    	cntrState.usrControl.btFlipFlop=1; 
        cntrState.usrControl.btFlipFlopTemp=0;
    }
	
	return;
}

/***************************************************************************//*!
*
* @brief   CALIBRATION state - ADC calibration state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateCalib()
{
    /*-----------------------------------------------------
      Application State Machine - state identification
    ----------------------------------------------------- */
    tBool           CalibStatus;

    cntrState.state    = calib;
    cntrState.event    = e_calib;
    CalibStatus        = false;

    // Turn off actuator output
    DisableOutput();

    CalibStatus = Meas_CalibCurrentSense(&meas, drvFOC.svmSector);

    // Apply 0.5 duty cycle
    drvFOC.pwm16.f16Arg1 = FRAC16(0.5);
    drvFOC.pwm16.f16Arg2 = FRAC16(0.5);
    drvFOC.pwm16.f16Arg3 = FRAC16(0.5);

    SetDutycycle(&drvFOC.pwm16, 2);

    // Exit the calibration state when DC calibration is done for all sectors
    if (CalibStatus)
    {
    	// Calibration sequence has successfully finished
		cntrState.event               = e_calib_done;    
    }
	return;
}

/***************************************************************************//*!
*
* @brief   ALIGNMENT state - motor control d-axes alignment
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateAlign( )
{
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    tBool           AlignStatus;

    cntrState.state   = align;
    cntrState.event   = e_align;

    // Turn on Actuator output on (PWM,GDU)
    EnableOutput();

    // Align sequence is at the beginning
    AlignStatus     = true;

    drvFOC.uDQReq.f16Arg1      = drvFOC.alignVoltage;
    drvFOC.uDQReq.f16Arg2      = FRAC16(0);

    drvFOC.thTransform.f16Arg1 = GFLIB_Sin(0);
    drvFOC.thTransform.f16Arg2 = GFLIB_Cos(0);

    GMCLIB_ParkInv(&(drvFOC.uAlBeReq),&(drvFOC.thTransform),&(drvFOC.uDQReq));
    drvFOC.svmSector = GMCLIB_SvmStd(&(drvFOC.pwm16),&(drvFOC.uAlBeReq));

    // when alignment time elapse
    if (--(drvFOC.alignCntr)<=0)
    {
    	if(cntrState.usrControl.FOCcontrolMode == speedControl)
    	{
			// Set state of the current loop to avoid a step change of the current
			AMCLIB_CurrentLoopSetState_F16(drvFOC.uDQReq.f16Arg1, drvFOC.uDQReq.f16Arg2, &drvFOC.currentLoop);
			
			drvFOC.currentLoop.pIDQReq->f16Arg1 = drvFOC.currentLoop.pIDQFbck->f16Arg1;
			drvFOC.currentLoop.pIDQReq->f16Arg2 = FRAC16(0.0);
			
			AMCLIB_CurrentLoop_F16(drvFOC.iCLoop_Limit, &drvFOC.uDQReq, &drvFOC.currentLoop);
    	}
    	else
    	{
    		drvFOC.currentLoop.pIDQReq->f16Arg1 = FRAC16(0.0);
    		drvFOC.currentLoop.pIDQReq->f16Arg2 = FRAC16(0.0);
    		
    		AMCLIB_CurrentLoopInit_F16(&drvFOC.currentLoop);
    		drvFOC.uDQReq.f16Arg1      = FRAC16(0.0);
    		drvFOC.uDQReq.f16Arg2      = FRAC16(0.0);
    	}
    	drvFOC.svmSector = 2;
        if (!AlignStatus)
        {
        	tempfaults.stateMachine.B.AlignError     = 1;
        }
        else
        {
        	cntrState.event           = e_align_done;
        }
    }

    SetDutycycle(&drvFOC.pwm16, drvFOC.svmSector);
	return;
}

/***************************************************************************//*!
*
* @brief   RUN state
*
* @param   none
*
* @return  none
*
******************************************************************************/
static tFrac16 newPospeSensorlessThRotEl = 0;
static tFrac16 newPospeSensorlessWRotEl = 0;

static tBool useOldValues = false;

void stateRun( )
{
    static tBool stateRunStatus;
    
    static tBool trackingToSensorless = false; 
    
    stateRunStatus = false;
    
    /*-----------------------------------------------------
    Application State Machine - state identification
    ----------------------------------------------------- */
    cntrState.state   = run;
    cntrState.event   = e_run;

    /*-----------------------------------------------------
        Calculate positions
     ----------------------------------------------------- */
    drvFOC.pospeControl.wRotElReqRamp = MLIB_Convert_F16F32(drvFOC.speedLoop.pRamp.f32State, FRAC32(1.0));
    drvFOC.pospeOpenLoop.wRotEl  = drvFOC.pospeControl.wRotElReqRamp;
    drvFOC.pospeOpenLoop.thRotEl = GFLIB_IntegratorTR_F16(drvFOC.pospeControl.wRotElReqRamp,&drvFOC.pospeOpenLoop.integ);
	
    
    // Start calculation of the Bemf Observer in tracking mode 
    if(pos_mode!=force)
    {
    	
    	drvFOC.pospeSensorless.DQtoGaDeError=AMCLIB_BemfObsrvDQ_F16(&drvFOC.iAlBeFbck, &drvFOC.uAlBeReq, drvFOC.pospeSensorless.wRotEl, drvFOC.pospeSensorless.thRotEl, &drvFOC.pospeSensorless.bEMFObs);
    	if(useOldValues)
    		AMCLIB_TrackObsrv_F16(drvFOC.pospeSensorless.DQtoGaDeError, &newPospeSensorlessThRotEl,  &newPospeSensorlessWRotEl, &drvFOC.pospeSensorless.TrackObsrv );
    	else
    		AMCLIB_TrackObsrv_F16(drvFOC.pospeSensorless.DQtoGaDeError, &drvFOC.pospeSensorless.thRotEl,  &drvFOC.pospeSensorless.wRotEl, &drvFOC.pospeSensorless.TrackObsrv );
    }

    if(useOldValues)
    	drvFOC.pospeOpenLoop.thDifOpenLEstim = MLIB_Sub_F16(newPospeSensorlessThRotEl, drvFOC.pospeOpenLoop.thRotEl);
    else
    	drvFOC.pospeOpenLoop.thDifOpenLEstim = MLIB_Sub_F16(drvFOC.pospeSensorless.thRotEl, drvFOC.pospeOpenLoop.thRotEl);
	/*-----------------------------------------------------
	Get positions according to selected mode
	----------------------------------------------------- */
	// Selecting 0 will disable the "AUTOMATIC MODE"
	// where the transition from open loop to sensorless in performed automaticaly
	// Selecting 1 will enable the "USER mode"
	// where user decide whether to switch to force mode, tracking mode, sensorless mode
    
    MotorDrive_uiActualSpeed=(MLIB_Abs_F16(drvFOC.pospeOpenLoop.wRotEl)*3000)>>15;  //add for El. speed output
    //l_u16_wr_LIN_NXP_ActSpeed((MotorDrive_uiActualSpeed/11));                //refresh actspeed
    
	if (cntrState.usrControl.controlMode == automatic)
	{
		//Automatic Mode switch
		if (MotorDrive_uiActualSpeed < drvFOC.pospeSensorless.wRotElMatch_1)	// Use open-loop for speeds below the Match1
		{
			pos_mode = force;
			trackingToSensorless = false;
		}
		else
		{
			if (MotorDrive_uiActualSpeed >= drvFOC.pospeSensorless.wRotElMatch_1 &&	// Switch to tracking between Match1 and Match2 
				 MotorDrive_uiActualSpeed < drvFOC.pospeSensorless.wRotElMatch_2) 
			{
				pos_mode = tracking;
				
			}
			else																				// Switch to sensorles above Match2
			{
				if(!trackingToSensorless)	// Just once the sensorless is entered, the speed PI controller needs to be reset to avoid step current changes 
				{
					trackingToSensorless = true;
					AMCLIB_CurrentLoopSetState_F16(drvFOC.uDQReq.f16Arg1, drvFOC.uDQReq.f16Arg2, &drvFOC.currentLoop);
					AMCLIB_SpeedLoopSetState_F16(drvFOC.pospeOpenLoop.wRotEl, drvFOC.iDQFbck.f16Arg2, MLIB_Convert_F32F16(drvFOC.pospeOpenLoop.wRotEl, FRAC16(1.0)), &drvFOC.speedLoop);
				}
				pos_mode = sensorless1;
			}
		}
		MotorDrive_MotorStatus=pos_mode;    //add motor state
	}
	
	// user/automatics decides whether to switch to force mode, tracking mode, sensorless mode
	switch (pos_mode)
	{
		case force:
			drvFOC.speedLoop.pPIpAWQ.f16UpperLimit = drvFOC.pospeOpenLoop.iQUpperLimit;
			drvFOC.speedLoop.pPIpAWQ.f16LowerLimit = MLIB_Neg_F16(drvFOC.speedLoop.pPIpAWQ.f16UpperLimit);
			
			drvFOC.pospeControl.thRotEl = drvFOC.pospeOpenLoop.thRotEl;
			drvFOC.pospeControl.wRotEl	= 0;
			
			drvFOC.speedRampPos.f32RampUp             = OL_SpeedRampInc;
			drvFOC.speedRampPos.f32RampDown           = OL_SpeedRampInc;
			
			drvFOC.speedRampNeg.f32RampUp             = OL_SpeedRampInc;
			drvFOC.speedRampNeg.f32RampDown           = OL_SpeedRampInc;
			
			drvFOC.pospeSensorless.wRotEl			= 0;
			drvFOC.pospeSensorless.thRotEl			= 0;
			
			AMCLIB_BemfObsrvDQInit_F16 (&drvFOC.pospeSensorless.bEMFObs);
					    
			drvFOC.pospeSensorless.TrackObsrv.pParamPI.f32Acc 		= MLIB_Convert_F32F16(drvFOC.pospeOpenLoop.wRotEl, FRAC16(1.0));
		    drvFOC.pospeSensorless.TrackObsrv.pParamInteg.f32State 	= MLIB_Convert_F32F16(drvFOC.pospeOpenLoop.thRotEl, FRAC16(1.0));
		break;
		case tracking:			
			drvFOC.pospeControl.thRotEl = drvFOC.pospeOpenLoop.thRotEl;
			drvFOC.pospeControl.wRotEl	= 0;	
			
			drvFOC.speedRampPos.f32RampUp             = OL_SpeedRampInc;
			drvFOC.speedRampPos.f32RampDown           = OL_SpeedRampInc;
			
			drvFOC.speedRampNeg.f32RampUp             = OL_SpeedRampInc;
			drvFOC.speedRampNeg.f32RampDown           = OL_SpeedRampInc;
		break;
		case sensorless1:
			drvFOC.speedLoop.pPIpAWQ.f16UpperLimit = drvFOC.pospeSensorless.iQUpperLimit;
			drvFOC.speedLoop.pPIpAWQ.f16LowerLimit = drvFOC.pospeSensorless.iQLowerLimit;
			
			drvFOC.pospeControl.thRotEl = drvFOC.pospeSensorless.thRotEl;
			drvFOC.pospeControl.wRotEl	= drvFOC.pospeSensorless.wRotEl;	

			drvFOC.speedRampPos.f32RampUp          = CL_SpeedRampInc;
			drvFOC.speedRampPos.f32RampDown        = CL_SpeedRampDec;
			
			drvFOC.speedRampNeg.f32RampUp          = CL_SpeedRampInc;  //CL_SpeedRampDec;
			drvFOC.speedRampNeg.f32RampDown        = CL_SpeedRampDec;  //CL_SpeedRampInc;
			
			drvFOC.pospeOpenLoop.integ.f32State = MLIB_Convert_F32F16(drvFOC.pospeSensorless.thRotEl, FRAC16(1.0));
		break;
	}
	

	/*-----------------------------------------------------
	    Calculate Field Oriented Control FOC
	----------------------------------------------------- */
	// Slow loop
    if (++drvFOC.pospeControl.speedLoopCntr>=SPEED_LOOP_CNTR)
    {
        drvFOC.pospeControl.speedLoopCntr    = 0;
        
        stateRunStatus  = focSlowLoop();
        if (!stateRunStatus)
        {
        	tempfaults.stateMachine.B.RunError = 1;
        }
    }

    // Fast loop
    stateRunStatus = focFastLoop();
    
    if (!stateRunStatus)
    {
    	tempfaults.stateMachine.B.RunError = 1;
    }

    SetDutycycle(&drvFOC.pwm16, drvFOC.svmSector);
    
	return;
}


/***************************************************************************//*!
*
* @brief   Field Oriented Control - slow loop calculations
*
* @param   
*
* @return  none
*
******************************************************************************/
static tBool focSlowLoop()
{
	tFrac16 current = 0;
	tFrac16 weight = 0;
	SWLIBS_2Syst_F16 tempIDQReq;
	
	if(cntrState.usrControl.FOCcontrolMode != speedControl)
	{
		// required speed for open loop start-up in sensorless mode = MERG_SPEED_1_TRH*1.5
		//wRotElReq = MERG_SPEED_1_TRH * 9.55 * 1.5 / pp = MERG_SPEED_1_TRH * 4.775 = ((MERG_SPEED_1_TRH*Frac16(0.596875)) << 3;
		if (cntrState.usrControl.FOCcontrolMode == voltageControl && drvFOC.uDQReq.f16Arg2==0) 
			drvFOC.pospeControl.wRotElReq = 0;
		else if (cntrState.usrControl.FOCcontrolMode == currentControl && drvFOC.currentLoop.pIDQReq->f16Arg2==0) 
			drvFOC.pospeControl.wRotElReq = 0;
		else if (cntrState.usrControl.FOCcontrolMode != scalarControl) 
			drvFOC.pospeControl.wRotElReq = MLIB_ShL_F16(MLIB_Mul_F16(FRAC16(0.75),MERG_SPEED_1_TRH),1);
	}
	
	// Switch the ramp based on the direction
	if(drvFOC.pospeControl.wRotElReqRamp >= 0)
	{
		drvFOC.speedLoop.pRamp.f32RampUp = drvFOC.speedRampPos.f32RampUp;
		drvFOC.speedLoop.pRamp.f32RampDown = drvFOC.speedRampPos.f32RampDown;
	}
	else
	{
		drvFOC.speedLoop.pRamp.f32RampUp = drvFOC.speedRampNeg.f32RampUp;
		drvFOC.speedLoop.pRamp.f32RampDown = drvFOC.speedRampNeg.f32RampDown;
	}
	// Limit the speed to 0.95 to prevent the controllers from saturation
	//if(drvFOC.pospeControl.wRotElReq > FRAC16(0.95))
	//	drvFOC.pospeControl.wRotElReq = FRAC16(0.95);
	//if(drvFOC.pospeControl.wRotElReq < FRAC16(-0.95))
	//	drvFOC.pospeControl.wRotElReq = FRAC16(-0.95);
	
	// Speed FO control mode
	drvFOC.pospeControl.wRotElErr = MLIB_Sub_F16(drvFOC.pospeControl.wRotElReq, drvFOC.pospeControl.wRotEl);
	AMCLIB_SpeedLoop_F16(drvFOC.pospeControl.wRotElReq, drvFOC.pospeControl.wRotEl, &tempIDQReq, &drvFOC.speedLoop);
	
	if(cntrState.usrControl.FOCcontrolMode == speedControl)
	{
		// Q-axis start-up
		//drvFOC.currentLoop.pIDQReq->f16Arg2         	= GFLIB_ControllerPIpAW(drvFOC.pospeControl.wRotElErr,&drvFOC.speedPI);
		
		// D to Q axis start-up 
		
		//AMCLIB_SpeedLoop_F16(drvFOC.pospeControl.wRotElReq, drvFOC.pospeControl.wRotEl, drvFOC.currentLoop.pIDQReq, &drvFOC.speedLoop);
		
		// In the force mode, open-loop algorithm is calculated based on the open-loop limits and loop parameters
		// In the tracking mode, a smooth transition from the open-loop to the closed-loop is performed by moving
		// 		the reference frame from D-axis to Q-axis, keeping the size of the current vector the same. Similar
		//		approach can be used for changing the speed controller limits from the open-loop to the closed-loop limits.
		//		The concept uses "weight" to calculate the actual speed relative to the Match1 - Match2 interval.
		// In the sensorless mode, closed-loop parameters are used to calculate the control loop.
		switch(pos_mode)
		{
		case force:
			current = drvFOC.pospeOpenLoop.iQUpperLimit;
			weight = 0;
			drvFOC.currentLoop.pIDQReq->f16Arg1 = current;
			drvFOC.currentLoop.pIDQReq->f16Arg2 = 0;
			drvFOC.speedLoop.pPIpAWQ.f16UpperLimit = drvFOC.pospeOpenLoop.iQUpperLimit;
			drvFOC.speedLoop.pPIpAWQ.f16LowerLimit = MLIB_Neg_F16(drvFOC.speedLoop.pPIpAWQ.f16UpperLimit);
			break;
		case tracking:
			current = drvFOC.pospeOpenLoop.iQUpperLimit;
			weight = MLIB_SubSat_F16(MLIB_Abs_F16(drvFOC.pospeOpenLoop.wRotEl),drvFOC.pospeSensorless.wRotElMatch_1);
			weight = MLIB_DivSat_F16(weight, MLIB_SubSat_F16(drvFOC.pospeSensorless.wRotElMatch_2,drvFOC.pospeSensorless.wRotElMatch_1));
			drvFOC.currentLoop.pIDQReq->f16Arg1 = MLIB_Mul_F16(GFLIB_Sqrt_F16(MLIB_SubSat_F16(FRAC16(1.0),weight)),current);
			drvFOC.currentLoop.pIDQReq->f16Arg2 = MLIB_Mul_F16(GFLIB_Sqrt_F16(weight),current);
			/* DISABLED for fan applications, where the load current is increasing with speed
			// Variable speed PI controller output limit between merging speed 1 and 2
			drvFOC.speedPI.f16UpperLimit = MLIB_AddSat_F16(
						MLIB_Mul_F16(drvFOC.pospeOpenLoop.iQUpperLimit, MLIB_SubSat_F16(FRAC16(1.0),weight)),
						MLIB_Mul_F16(drvFOC.pospeSensorless.iQUpperLimit,weight));
			drvFOC.speedPI.f16LowerLimit = MLIB_AddSat_F16(
					MLIB_Mul_F16(drvFOC.pospeOpenLoop.iQLowerLimit, MLIB_SubSat_F16(FRAC16(1.0),weight)),
					MLIB_Mul_F16(drvFOC.pospeSensorless.iQLowerLimit,weight));
			*/
			break;
		case sensorless1:
			current = tempIDQReq.f16Arg2;
			weight = FRAC16(1.0);
			drvFOC.currentLoop.pIDQReq->f16Arg1 = 0;
			drvFOC.currentLoop.pIDQReq->f16Arg2 = current;
			drvFOC.speedLoop.pPIpAWQ.f16UpperLimit = drvFOC.pospeSensorless.iQUpperLimit;
			drvFOC.speedLoop.pPIpAWQ.f16LowerLimit = drvFOC.pospeSensorless.iQLowerLimit;
			break;
		}
	}
	
    return true;
}

/***************************************************************************//*!
*
* @brief   Field Oriented Control - fast loop calculations
*
* @param   
*
* @return  none
*
******************************************************************************/
volatile unsigned int dPI = 1, qPI = 1;
volatile tBool useDecoupling = false;
volatile tFrac16 thetaOffset = 0;
static tBool focFastLoop()
{
	GMCLIB_Clark(&drvFOC.iAlBeFbck,&drvFOC.iAbcFbck);
	
	// Scalar control mode
	if(cntrState.usrControl.FOCcontrolMode == scalarControl)
	{
		// generated electrical position for scalar control purpose
		// Required voltage = VHzRatio * Required Frequency
		drvFOC.scalarControl.UmReq	  	= MLIB_ShL_F16(MLIB_Mul(drvFOC.scalarControl.VHzRatioReq,drvFOC.pospeControl.wRotElReqRamp),drvFOC.scalarControl.VHzRatioReq_Shift);

		// thRotEl is calculated in CalcOpenLoop executed in focSlowLoop
		drvFOC.thTransform.f16Arg1     = GFLIB_Sin(drvFOC.pospeControl.thRotEl);
		drvFOC.thTransform.f16Arg2     = GFLIB_Cos(drvFOC.pospeControl.thRotEl);

		drvFOC.uDQReq.f16Arg1          = 0;
		drvFOC.uDQReq.f16Arg2          = drvFOC.scalarControl.UmReq;
		
		// enable Bemf observer  
		cntrState.usrControl.controlMode = manual;
		pos_mode = tracking;
	}
	
	// DQ Voltage FO control mode
	if(cntrState.usrControl.FOCcontrolMode == voltageControl)
	{
		if(drvFOC.uDQReq.f16Arg2!=0)
		{
			drvFOC.thTransform.f16Arg1     = GFLIB_Sin(drvFOC.pospeControl.thRotEl);
			drvFOC.thTransform.f16Arg2     = GFLIB_Cos(drvFOC.pospeControl.thRotEl);
		}
		else
		{
			drvFOC.thTransform.f16Arg1     = 0;
			drvFOC.thTransform.f16Arg2     = FRAC16(FRACT_MAX);
		}
	
		GMCLIB_Park(&drvFOC.iDQFbck,&drvFOC.thTransform,&drvFOC.iAlBeFbck);
	}
	
	// DQ Current and Speed FO control mode
	if(cntrState.usrControl.FOCcontrolMode == currentControl || cntrState.usrControl.FOCcontrolMode == speedControl)
	{
		if(cntrState.usrControl.FOCcontrolMode == speedControl)
		{
			drvFOC.thTransform.f16Arg1     = GFLIB_Sin(drvFOC.pospeControl.thRotEl);
			drvFOC.thTransform.f16Arg2     = GFLIB_Cos(drvFOC.pospeControl.thRotEl);
		}
		else
		{
			if(drvFOC.currentLoop.pIDQReq->f16Arg2==0)
			{
				drvFOC.thTransform.f16Arg1     = 0;
				drvFOC.thTransform.f16Arg2     = FRAC16(FRACT_MAX);
			}
			else
			{
				drvFOC.thTransform.f16Arg1     = GFLIB_Sin(drvFOC.pospeControl.thRotEl);
				drvFOC.thTransform.f16Arg2     = GFLIB_Cos(drvFOC.pospeControl.thRotEl);
			}
		}

		GMCLIB_Park(&drvFOC.iDQFbck,&drvFOC.thTransform,&drvFOC.iAlBeFbck);
		
		AMCLIB_CurrentLoop_F16(drvFOC.iCLoop_Limit, &drvFOC.uDQReq, &drvFOC.currentLoop);
	}
	//////////////////////////////////////
	if(useOldValues)
	{
		drvFOC.pospeSensorless.thRotEl	= MLIB_Add_F16(newPospeSensorlessThRotEl, thetaOffset);
		drvFOC.pospeSensorless.wRotEl 	= newPospeSensorlessWRotEl;
	}
	
	/* Decoupling */
	GMCLIB_DecouplingPMSM_F16 (&drvFOC.uDQdecoupled, &drvFOC.uDQReq, &drvFOC.iDQFbck, drvFOC.pospeControl.wRotEl, &drvFOC.decouplingPar);
	
	if(useDecoupling)
		GMCLIB_ParkInv(&drvFOC.uAlBeReq,&drvFOC.thTransform,&drvFOC.uDQdecoupled);
	else
		GMCLIB_ParkInv(&drvFOC.uAlBeReq,&drvFOC.thTransform,&drvFOC.uDQReq);

	// DC Bus ripple elimination
	drvFOC.elimDcbRip.f16ArgDcBusMsr  = useRawDCBusForElim ? meas.measured.f16Udcb.raw : meas.measured.f16Udcb.filt;
	GMCLIB_ElimDcBusRip(&drvFOC.uAlBeReqDCB,&drvFOC.uAlBeReq,&drvFOC.elimDcbRip);
	
	/// The output needs to be limited to prevent the duty cycle to be higher than expected.
	//  Otherwise ADC restart error may occur due to the triggers placed too early after the reload
	drvFOC.uAlBeReqDCB.f16Arg1 = GFLIB_Limit_F16(drvFOC.uAlBeReqDCB.f16Arg1, &drvFOC.pospeSensorless.dutyCycleLimit);
	drvFOC.uAlBeReqDCB.f16Arg2 = GFLIB_Limit_F16(drvFOC.uAlBeReqDCB.f16Arg2, &drvFOC.pospeSensorless.dutyCycleLimit);

	drvFOC.svmSector   = GMCLIB_SvmStd(&(drvFOC.pwm16),&drvFOC.uAlBeReqDCB);

    return (true);
}


/***************************************************************************//*!
*
* @brief   Fault Detection function
*
* @param   none
*
* @return  none
*
******************************************************************************/
static tBool faultDetection()
{
    tBool faultDetectiontEvent;

    faultDetectiontEvent = false;
    //-----------------------------
    // Actual Faults
    //-----------------------------
//    // TRIP:   Phase A over-current detected
//	tempfaults.motor.B.OverPhaseACurrent = (drvFOC.iAbcFbck.f16Arg1 > MLIB_Mul_F16(I_PH_OVER,FRAC16(0.9))) ? true : false;
//
//	// TRIP:   Phase B over-current detected
//	tempfaults.motor.B.OverPhaseBCurrent = (drvFOC.iAbcFbck.f16Arg2 > MLIB_Mul_F16(I_PH_OVER,FRAC16(0.9))) ? true : false;
//
//	// TRIP:   Phase C over-current detected
//	tempfaults.motor.B.OverPhaseCCurrent = (drvFOC.iAbcFbck.f16Arg3 > MLIB_Mul_F16(I_PH_OVER,FRAC16(0.9))) ? true : false;
//
//	// TRIP:   DC-bus over-voltage
//	tempfaults.motor.B.OverDCBusVoltage  = (meas.measured.f16Udcb.raw > U_DCB_TRIP) ? true : false;
//
//	// TRIP:   DC-bus under-voltage
//	tempfaults.motor.B.UnderDCBusVoltage = (meas.measured.f16Udcb.raw < MLIB_Div_F16(U_DCB_UNDERVOLTAGE,FRAC16(0.91))) ? true : false;
//	
//	// Fault:   Over temperature
//	tempfaults.motor.B.OverHeating   	   = (meas.measured.f16Temp.filt > MLIB_Mul_F16(TEMP_OVER,FRAC16(0.9))) ? true : false;

	//-----------------------------
	// Pending Faults
	//-----------------------------

	if (cntrState.state != fault)
	{
//		// Fault:   Phase A over-current detected
//		permFaults.motor.B.OverPhaseACurrent   = (drvFOC.iAbcFbck.f16Arg1 > I_PH_OVER) ? true : permFaults.motor.B.OverPhaseACurrent;
//
//		// Fault:   Phase B over-current detected
//		permFaults.motor.B.OverPhaseBCurrent   = (drvFOC.iAbcFbck.f16Arg2 > I_PH_OVER) ? true : permFaults.motor.B.OverPhaseBCurrent;
//
//		// Fault:   Phase C over-current detected
//		permFaults.motor.B.OverPhaseCCurrent   = (drvFOC.iAbcFbck.f16Arg3 > I_PH_OVER) ? true : permFaults.motor.B.OverPhaseCCurrent;

//		// Fault:   DC-bus over-voltage
//		permFaults.motor.B.OverDCBusVoltage    = (meas.measured.f16Udcb.raw > U_DCB_OVERVOLTAGE) ? true : permFaults.motor.B.OverDCBusVoltage;
//
//		// Fault:   DC-bus under-voltage
//		if((cntrState.state > init)&&(cntrState.state < reset))
//			permFaults.motor.B.UnderDCBusVoltage   = (meas.measured.f16Udcb.filt < U_DCB_UNDERVOLTAGE) ? true : permFaults.motor.B.UnderDCBusVoltage;
//		else
//			permFaults.motor.B.UnderDCBusVoltage   = false;			

		// Fault:   Over temperature
		permFaults.motor.B.OverHeating  = (meas.measured.f16Temp.filt > TEMP_OVER) ? true : permFaults.motor.B.OverHeating;
		
		// Fault:	Sensorless error - estimated speed is of opposite polarity than required speed - e.g. estimation is not aligned with the real speed after Match speed 2
		if(MLIB_Abs_F16(drvFOC.pospeControl.wRotElReqRamp) > drvFOC.pospeSensorless.wRotElMatch_2)
		{
			if(MLIB_Mul_F16(drvFOC.pospeControl.wRotEl, drvFOC.pospeControl.wRotElReqRamp) < 0)
				permFaults.stateMachine.B.FOCError		= true;
		}
		
		permFaults.mcu.B.GDU_Error = GetDriverError();
		permFaults.mcu.B.PWM_Error = GetPMF_Faults();
		permFaults.mcu.B.PTU_Error = GetPTU_Errors();
	}


    if ((permFaults.motor.R != 0x0))
    	faultDetectiontEvent = true;
    if ((permFaults.mcu.R != 0x0))
        faultDetectiontEvent = true;
    if ((permFaults.stateMachine.R != 0x0))
        faultDetectiontEvent = true;

    return faultDetectiontEvent;
}

/* LED application control*/
/***************************************************************************//*!
*
* @brief   LED OFF state
*
* @param   
*
* @return  none
*
******************************************************************************/
void stateLedOFF()
{
	PTS_PTS4 = 0;
	return;
}

/***************************************************************************//*!
*
* @brief   LED ON state
*
* @param   
* 
* @return  none
*
******************************************************************************/
void stateLedON()
{
	PTS_PTS4 = 1;
	return;
}

/***************************************************************************//*!
*
* @brief   LED FLASHING state
*
* @param    
* 
* @return  none
*
******************************************************************************/
void stateLedFLASHING_SLOW()
{
	if((cntrState.usrControl.ledCounter++)>((cntrState.usrControl.ledFlashing)<<1))
	{
		PTS_PTS4 ^= 1;
		cntrState.usrControl.ledCounter = 0;
	}
	return;
}

/***************************************************************************//*!
*
* @brief   LED FLASHING state
*
* @param    
* 
* @return  none
*
******************************************************************************/
void stateLedFLASHING_FASTER()
{
	if((cntrState.usrControl.ledCounter++)>((cntrState.usrControl.ledFlashing>>1)<<1))
	{
		PTS_PTS4 ^= 1;
		cntrState.usrControl.ledCounter = 0;
	}
	return;
}

/***************************************************************************//*!
*
* @brief   LED FLASHING state
*
* @param    
*
* @return  none
*
******************************************************************************/
void stateLedFLASHING_FAST()
{
	if((cntrState.usrControl.ledCounter++)>((cntrState.usrControl.ledFlashing)>>1))
	{
		PTS_PTS4 ^= 1;
		cntrState.usrControl.ledCounter = 0;
	}
	return;
}
